<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <button onclick="startstop()">button</button>
    <!-- <script type="text/javascript" src="voice-commands.js"></script>

    <script>
        var step = 1;
        var results = [];
        SPEECH.onStart(function() {});
        SPEECH.onResult(function(result) {
            if (step === 1) {
                step = 2;
            }
            results.push(result);
        });
        const startstop = () => {
            SPEECH.start({
                min_confidence: 0.2,
            });
        };
    </script> -->
    <script>
      const startstop = () => {
        // appends an audio element to playback and download recording
        function createAudioElement(blobUrl) {
          const downloadEl = document.createElement("a");
          downloadEl.style = "display: block";
          downloadEl.innerHTML = "download";
          downloadEl.download = "audio.mp3";
          downloadEl.href = blobUrl;
          const audioEl = document.createElement("audio");
          audioEl.controls = true;
          const sourceEl = document.createElement("source");
          sourceEl.src = blobUrl;
          sourceEl.type = "audio/mp3";
          audioEl.appendChild(sourceEl);
          document.body.appendChild(audioEl);
          document.body.appendChild(downloadEl);
        }

        // request permission to access audio stream
        navigator.mediaDevices
          .getUserMedia({
            audio: true,
          })
          .then((stream) => {
            // store streaming data chunks in array
            const chunks = [];
            // create media recorder instance to initialize recording
            const recorder = new MediaRecorder(stream);
            // function to be called when data is received
            recorder.ondataavailable = (e) => {
              // add stream data to chunks
              chunks.push(e.data);
              // if recorder is 'inactive' then recording has finished
              if (recorder.state == "inactive") {
                // convert stream data chunks to a 'webm' audio format as a blob
                const blob = new Blob(chunks, {
                  type: "audio/mp3",
                });
                // convert blob to URL so it can be assigned to a audio src attribute
                createAudioElement(URL.createObjectURL(blob));
              }
            };
            // start recording with 1 second time between receiving 'ondataavailable' events
            recorder.start(1000);
            // setTimeout to stop recording after 4 seconds
            setTimeout(() => {
              // this will trigger one final 'ondataavailable' event and set recorder state to 'inactive'
              recorder.stop();
            }, 4000);
          })
          .catch(console.error);
      };
    </script>
  </body>
</html>
